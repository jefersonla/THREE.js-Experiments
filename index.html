<!DOCTYPE html>
<html>

<head>
  <meta charset=utf-8>
	<title>My first three.js app</title>
	<style>
		html, body {
      margin: 0 auto;
      padding: 0;
      width: 100%;
      height: 100%;
    }
    body{
      display: flex;
      align-items: center;
    }
		#canvasRenderer {
      margin: 0 auto;
      /*
      width: 800px !important;
      height: 500px !important;
      */
      width: 100% !important;
      height: 100% !important;
    }
	</style>
</head>

<body>

  <!-- Libraries -->
  <script src="js/three.js"></script>
  <script src="js/stats.js"></script>
  <script src="js/dat.gui.js"></script>
  <script src="js/oimo.js"></script>

  <!-- Three.js Extensions -->
  <script src="js/Detector.js"></script>
  <script src="js/STLLoader.js"></script>
  <script src="js/OrbitControls.js"></script>

	<script>

    ////// EXPERIMENTAL PHYSICS
    var world = new OIMO.World( {info:true, worldscale:100} );
    var ground = world.add({size:[1000, 1, 1000], pos:[0,-1,0]});

    // Enable Visual Debug
    var VISUAL_DEBUG = false;

    // Check if we have webgl
    if (!Detector.webgl) Detector.addGetWebGLMessage();

    // Global objects
    var renderer = null,
        camera,
        scene,
        controls,
        axes,
        groundPlane,
        meshObjects,
        bonesArray,
        bonesArticulations,
        quadrupedSkeleton,
        stats;

    // Box Helpers
    var boxHelperVector = [];

    // Groups are collection of meshs
    var meshGroups = {
      servoModel: {
        isBone: false,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {}
      },
      legSupport: {
        isBone: true,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          legServo: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: 0,
                y: 0,
                z: 0
              },
              rotation: {
                x: 0,
                y: 0,
                z: 0
              }
            }
          }
        }
      },
      servoSupport:{
        isBone: false,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          legServo: {
            groupModel: "legSupport",
            properties: {
              position: {
                x: 0,
                y: 0,
                z: 0
              },
              rotation: {
                x: 0,
                y: 0,
                z: 0
              }
            }
          }
        }
      },
      legModel:{
        isBone: true,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          legServo: {
            groupModel: "servoSupport",
            properties: {
              position: {
                x: 0,
                y: -40.5,
                z: -1.6
              },
              rotation: {
                x: 0,
                y: 0,
                z: 0
              }
            }
          }
        }
      },
      bodyCover: {
        isBone: false,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          staticServoFL: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: -31,
                y: 5,
                z: 26.9
              },
              rotation: {
                x: THREE.Math.degToRad(90),
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(270)
              }
            }
          },
          staticServoFR: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: 31,
                y: 5,
                z: 26.9
              },
              rotation: {
                x: THREE.Math.degToRad(90),
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(270)
              }
            }
          },
          staticServoBL: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: -31,
                y: 5,
                z: -26.9
              },
              rotation: {
                x: THREE.Math.degToRad(90),
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(90)
              }
            }
          },
          staticServoBR: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: 31,
                y: 5,
                z: -26.9
              },
              rotation: {
                x: THREE.Math.degToRad(90),
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(90)
              }
            }
          }
        }
      },
      body:{
        isBone: true,
        visible: true,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          staticBody: {
            groupModel: "bodyCover",
            properties: {
              position: {
                x: 0,
                y: 47.5,
                z: 0
              },
              rotation: {
                x: 0,
                y: 0,
                z: 0
              }
            }
          },
          legFrontLeft:{
            groupModel: "legModel",
            properties: {
              position: {
                x: -31,
                y: 53.5,
                z: 26.8
              },
              rotation: {
                x: 0,
                y: 0,
                z: THREE.Math.degToRad(270)
              }
            }
          },
          legBackLeft:{
            groupModel: "legModel",
            properties: {
              position: {
                x: -31,
                y: 53.5,
                z: -26.8
              },
              rotation: {
                x: 0,
                y: 0,
                z: THREE.Math.degToRad(270)
              }
            }
          },
          legBackRight:{
            groupModel: "legModel",
            properties: {
              position: {
                x: 31,
                y: 53.5,
                z: -26.8
              },
              rotation: {
                x: 0,
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(270)
              }
            }
          },
          legFrontRight:{
            groupModel: "legModel",
            properties: {
              position: {
                x: 31,
                y: 53.5,
                z: 26.8
              },
              rotation: {
                x: 0,
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(270)
              }
            }
          }
        }
      }
    }

    // ----------------------------------------------------------

    // Objects positions
    var objsToLoad = {
      sg90Servo : {
        path: "./parts/sg90Servo.stl",
        groups: ["servoModel"],
        color: null,
        properties: {
          position: {
            x: -9.85,
            y: -51,
            z: 5
          },
          rotation: {
            x: 0,
            y: 0,
            z: 0
          }
        }
      },
      servoBottom : {
        path: "./parts/servoBottom.stl",
        groups: ["servoModel"],
        color: null,
        properties: {
          position: {
            x: 5.3,
            y: 0,
            z: -11
          },
          rotation: {
            x: 0,
            y: THREE.Math.degToRad(180),
            z: THREE.Math.degToRad(-90)
          }
        }
      },
      servoSupportX : {
        path: "./parts/servoSupport.stl",
        groups: ["servoSupport"],
        color: 0x37EA10,
        properties: {
          position: {
            x: 5.4,
            y: 11,
            z: 15
          },
          rotation: {
            x: THREE.Math.degToRad(-90),
            y: THREE.Math.degToRad(-90),
            z: THREE.Math.degToRad(180)
          },
          scale: {
            x: 1,
            y: 0.9,
            z: 0.9
          }
        }
      },
      servoSupportY : {
        path: "./parts/servoSupport.stl",
        groups: ["servoSupport"],
        color: 0x37EA10,
        properties: {
          position: {
            x: -13.2,
            y: 29.4,
            z: -3.7
          },
          rotation: {
            x: THREE.Math.degToRad(180),
            y: THREE.Math.degToRad(180),
            z: THREE.Math.degToRad(-90)
          },
          scale: {
            x: 1,
            y: 0.9,
            z: 0.9
          }
        }
      },
      leg : {
        path: "./parts/leg.stl",
        groups: ["legSupport"],
        color: 0xEA9610,
        properties: {
          position: {
            x: 5,
            y: 0,
            z: -5
          },
          rotation: {
            x: 0,
            y: 0,
            z: THREE.Math.degToRad(90)
          }
        }
      },
      bodyCover : {
        path: "./parts/bodyCover.stl",
        groups: ["bodyCover"],
        color: 0x3010EA,
        properties: {
          position: {
            x: 0,
            y: 10,
            z: 0
          },
          rotation: {
            x: THREE.Math.degToRad(-90),
            y: 0,
            z: THREE.Math.degToRad(180)
          }
        }
      },
      body : {
        path: "./parts/body.stl",
        groups: ["bodyCover"],
        color: 0x8710EA,
        properties: {
          position: {
            x: 0,
            y: 10,
            z: 0
          },
          rotation: {
            x: THREE.Math.degToRad(90),
            y: 0,
            z: 0
          }
        }
      },
      bodyBottom : {
        path: "./parts/bodyBottom.stl",
        groups: ["bodyCover"],
        color: 0x3010EA,
        properties: {
          position: {
            x: 0,
            y: 0,
            z: 0
          },
          rotation: {
            x: THREE.Math.degToRad(90),
            y: 0,
            z: THREE.Math.degToRad(180)
          }
        }
      }
    };

    // Size of objsToLoad
    // <3 https://stackoverflow.com/questions/126100/how-to-efficiently-count-the-number-of-keys-properties-of-an-object-in-javascrip
    var objsToLoadSize = Object.keys(objsToLoad).length;

    // Box3 Temp reusable object
    // <3 https://stackoverflow.com/questions/41459512/from-boundingboxhelper-to-boxhelper
    var box3Size = new THREE.Box3();
    var objSize = new THREE.Vector3();

    // Count number of objects loaded
    var LOADED_OBJECTS_NUMBER = 0;

    // Init content and animate it's scene
    init();
    animate();

    // Init function
    function init(){

      // Create a new scene
      scene = new THREE.Scene();

      // TODO Add a different background color
      //scene.background = new THREE.Color( 0x72645b );

      // Add a fog enviroment at end
      scene.fog = new THREE.Fog( 0x72645b, 500, 800 );

      // Create a new WebGLRenderer, set it's size and it's color
      createRenderer(false);

      // Create a new camera
      //camera = new THREE.PerspectiveCamera(50, 800 / 500, 1, 10000);
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.set(0, 150, 250);
      camera.lookAt(scene.position);

      // Create a fake camera and render a custom frame just to update projection matrix
      // of this camera and project the camera helper accordily
      //var fakeCamera = new THREE.PerspectiveCamera(50, 800 / 500, 1, 10000);
      var fakeCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
      fakeCamera.position.set(0, 150, 250);
      fakeCamera.lookAt(scene.position);
      renderer.render(scene, fakeCamera);

      // Add a camera helper to help with orientation
      if(VISUAL_DEBUG){
        var cameraHelper = new THREE.CameraHelper( fakeCamera );
        cameraHelper.matrixAutoUpdate = false;
        scene.add( cameraHelper );
      }

      // Add a grid to help with orientation
      if(VISUAL_DEBUG){
        var gridHelper = new THREE.GridHelper( 400, 40, 0x0000ff, 0x808080 );
    		scene.add(gridHelper);
      }

      // Create an axis helper to help with orientation
      if(VISUAL_DEBUG){
        axes = new THREE.AxesHelper(1000);
        axes.position.y = 0.1;
        scene.add(axes);
      }

      // Create an hemisphere light and add it to scene
      var hemisphereLight = new THREE.HemisphereLight(0x443333, 0x111122);
      scene.add(hemisphereLight);

      // Create an spotlight, which can cast shadows
      var spotLight = new THREE.SpotLight( 0xffffff );
      spotLight.position.set( 0, 500, 0 );

      // Enable shadow
      spotLight.castShadow = true;

      // Configure map size
      spotLight.shadow.mapSize.width = 1024;
      spotLight.shadow.mapSize.height = 1024;

      // Configure shadow
      spotLight.shadow.camera.near = 200;
      spotLight.shadow.camera.far = 800;
      spotLight.shadow.camera.fov = 1;

      // Add spotlight to scene
      scene.add(spotLight);

      // Add a spotlight helper to help orientation
      if(VISUAL_DEBUG){
        var spotLightHelper = new THREE.SpotLightHelper( spotLight );
        scene.add( spotLightHelper );
      }

      // Create the loader for STL files
      var loader = new THREE.STLLoader();

      // Add a plane to represent ground on this scene
      var planeGeometry = new THREE.PlaneBufferGeometry(4000, 4000, 32, 32);
      var planeMaterial = new THREE.MeshStandardMaterial({ color: 0xfffffff });
      groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
      groundPlane.rotation.x = THREE.Math.degToRad(-90);
      groundPlane.receiveShadow = true;
      scene.add(groundPlane);

      // Create an array to organize every mesh
      meshObjects = [];

      // Add a event listener to all objects
      function loadSTL(objName){

        return ((geometry) => {

          // Create material which is the apparence of the object
          var material;
          if (objsToLoad[objName].color !== null){
            material = new THREE.MeshPhongMaterial({
              color: objsToLoad[objName].color,
              specular: 0x111111,
              shininess: 200
            });
          } else {
            material = new THREE.MeshPhongMaterial({
              color: 0xCCC,
              specular: 0x111111,
              shininess: 200
            });
          }

          // Join geometry and it's material to create the mesh
          var mesh = new THREE.Mesh(geometry, material);

          // Add shadow to the mesh
          mesh.castShadow = true;
          mesh.receiveShadow = true;

          // If this object has custom properties change them now
          for(let propertyName in objsToLoad[objName].properties){
            for(let propertyValue in objsToLoad[objName].properties[propertyName]){
              mesh[propertyName][propertyValue] = objsToLoad[objName].properties[propertyName][propertyValue];
            }
          }

          // Add copies of this mesh to the custom groups
          for(var i = 0; i < objsToLoad[objName].groups.length; i++){
            // Group name
            var groupName = objsToLoad[objName].groups[i];
            console.log("Cloning mesh " + objName + " to group " + groupName);

            // Create a clone of this mesh
            var meshClone = mesh.clone();

            // Add this copie to the group and the array of meshs in group
            meshGroups[groupName].groupObject.add(meshClone);
            meshGroups[groupName].meshChilds[objName] = meshClone;
          }

          // Add the object to scene if this mesh don't belong to a group
          if(objsToLoad[objName].groups.length === 0){
            console.log("Obj " + objName + " being added to scene");
            meshObjects[objName] = mesh;
            scene.add(mesh);

            // In DEBUG situations add a box helper to mesh to check it's sizes
            if(VISUAL_DEBUG){
              var boxHelper = new THREE.BoxHelper( mesh, 0xffff00 );
              scene.add(boxHelper);
              boxHelperVector.push(boxHelper);
            }

            // Display object size
            displayObjectSize(objName, boxHelper);
          }

          // Increment counter of loaded objects
          LOADED_OBJECTS_NUMBER++;

          // If all objects are loaded then call function to organize groups
          if(LOADED_OBJECTS_NUMBER === objsToLoadSize){
            organizeGroups();
          }

        });

      }

      // Initialize mesh groups
      for(let groupName in meshGroups){

        // Create the group object or bone object
        if(meshGroups[groupName].isBone){
          meshGroups[groupName].groupObject = new THREE.Bone();
        } else {
          meshGroups[groupName].groupObject = new THREE.Group();
        }

        // Create a box to represent pivot
        // TODO Not necessarily now, maybe on the future

      }

      // Load all stl files in the desired position
      for(let stlObj in objsToLoad){
        console.log("Loading - " + objsToLoad[stlObj].path);
        loader.load(objsToLoad[stlObj].path, loadSTL(stlObj));
      }

      // Create perfomance stats
      stats = new Stats();
			document.body.appendChild( stats.dom );

      // Add a mouse controller for this scene
      controls = new THREE.OrbitControls(camera, renderer.domElement);

      // Disable vertical rotation below ground plane
      controls.maxPolarAngle = Math.PI/2 - 0.1;
      controls.minPolarAngle = -Math.PI/2;

      // Add an event listener to reset camera position
      document.addEventListener('keypress', (event) => {
        // Get pressed key
        var key = event.which || event.keyCode;

        // Uncomment this to discover what is the code ok key pressed
        //console.log("DEBUG -- Key pressed => " + key);

        // Key 'r' has code 114
        var keyR = 114;

        // Check if pressed key b and reset it's control
        if(key === keyR){
          controls.reset();
          console.log("Resetting controls...");
        }
      });

      // Add an event listener to window resize event
      window.addEventListener('resize', onWindowResize, false);
    }

    // Animate scene
    function animate(){

      // Initialize stats
      stats.begin();

      // Update controls
      controls.update();

      // Update box helpers in scene
      if(VISUAL_DEBUG){
        for(var i = 0; i < boxHelperVector.length; i++){
          boxHelperVector[i].update();
        }
      }

      // Re-render this scene
      render();

      // End of monitored stats
      stats.end();

      // Request this animation frame recursively
      requestAnimationFrame(animate);
    }

    // Render scene content
    function render(){
      renderer.render(scene, camera);
    }

    // Display size of an 3D Object
    function displayObjectSize(objName, obj){
      // Get a bounding box from the obj
      box3Size.setFromObject(obj);

      // Change size vector3 to display size of this object
      box3Size.getSize(objSize);

      // Display object size
      console.log("Sizes of " + objName +
                  " X: " + objSize.x,
                  " Y: " + objSize.y,
                  " Z: " + objSize.z);
    }

    // Organize groups since all content are loaded
    function organizeGroups(){

      // Debug message
      console.log("Organizing groups...");

      // For each group in mesh groups
      for(let groupName in meshGroups){

        // Check if we use another object inside this group and add a copy of it to this
        for(let auxObjID in meshGroups[groupName].usedObjects){

          // Get auxObjName with obj id
          var auxObjName = meshGroups[groupName].usedObjects[auxObjID].groupModel;

          // Copy of aux obj
          var cloneAuxObj = meshGroups[auxObjName].groupObject.clone();

          // Add this aux obj to the current group
          console.log("Appending obj " + auxObjName + " to group " + groupName);
          meshGroups[groupName].groupObject.add(cloneAuxObj);
          meshGroups[groupName].meshChilds[auxObjID] = cloneAuxObj;

          // In case of this cloned group has custom properties change them now
          for(let propertyName in meshGroups[groupName].usedObjects[auxObjID].properties){
            for(let propertyValue in meshGroups[groupName].usedObjects[auxObjID].properties[propertyName]){
              cloneAuxObj[propertyName][propertyValue] = meshGroups[groupName].usedObjects[auxObjID]
                                                                              .properties[propertyName][propertyValue];
            }
          }
        }

        // Add this group to scene if it's visible
        if(meshGroups[groupName].visible){
          // In DEBUG situations add a box helper to mesh to check it's sizes
          if(VISUAL_DEBUG){
            var boxHelper = new THREE.BoxHelper( meshGroups[groupName].groupObject, 0xffff00 );
            scene.add(boxHelper);
            boxHelperVector.push(boxHelper);
          }

          // Bones array, add this as first bone
          bonesArray = [meshGroups[groupName].groupObject];

          // Bones articulations
          // TODO since now we have only one bone per articulation create an obj
          // with a list of bones per articulation
          bonesArticulations = {};

          // For every bone which belong to childs of this group
          for(let groupNameID in meshGroups[groupName].meshChilds){

            // Check if it's a bone
            if(meshGroups[groupName].meshChilds[groupNameID].type === "Bone"){
              // Get reference of the actual boneObj
              var boneObj = meshGroups[groupName].meshChilds[groupNameID];

              // Add a green box helper for articulations
              if(VISUAL_DEBUG){
                var boxHelper = new THREE.BoxHelper( boneObj, 0x002aff );
                scene.add(boxHelper);
                boxHelperVector.push(boxHelper);
              }

              // Since we are a bone add this to list of bones
              bonesArray.push(boneObj);

              // Save an array of bones in this articulation to change properties after
              bonesArticulations[groupNameID] = [];

              // This function return every bone in an articulation
              function returnBonesRec(objsBones, bonesFound){

                // Check children of this bone
                for(var i = 0; i < objsBones.children.length; i++){
                  // Check if it's a bone and call this function recursively
                  if(objsBones.children[i].type === "Bone"){
                    // Get actual bone
                    var actualBone = objsBones.children[i];

                    // Add a blue box helper to basic bones
                    if(VISUAL_DEBUG){
                      var boxHelper = new THREE.BoxHelper( actualBone, 0x00ff19 );
                      scene.add(boxHelper);
                      boxHelperVector.push(boxHelper);
                    }

                    // Add to the array of bones
                    bonesArray.push(actualBone);

                    // Add to the bonesFound array too
                    bonesFound.push(actualBone);
                  }

                  // Call this function recursively
                  returnBonesRec(objsBones.children[i], bonesFound);
                }
              }

              // Get all bones of this articulation
              returnBonesRec(boneObj, bonesArticulations[groupNameID]);
            }

            // Quadruped skeleton
            quadrupedSkeleton = new THREE.Skeleton( bonesArray );

            // Bind skeleton to this group mesh
            //meshGroups[groupName].groupObject.bind(quadrupedSkeleton);

            // Add a skeleton helper to scene
            //var skeletonHelper = new THREE.SkeletonHelper( quadrupedSkeleton );
            //skeletonHelper.material.linewidth = 3;
            //scene.add( skeletonHelper );

          }

          // Since now we have all the bones we can create the change interface
          createGui();

          // Add group to scene
          scene.add(meshGroups[groupName].groupObject);
        }

      }

    }

    // Create a renderer
    function createRenderer(enableAntiAlias){
      // Delete dom renderer element from page if it's already exist
      var recreateDom = false;
      if(renderer !== null){
        console.log("Recreating renderer dom");
        recreateDom = true;
        renderer.domElement.parentElement.removeChild(renderer.domElement);
      }

      // Enable anti alias
      if(enableAntiAlias){
        // Create renderer and set some properties
        renderer = new THREE.WebGLRenderer({ antialias: true });

        // Antialias the shadows
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      } else {
        // Create renderer and set some properties
        renderer = new THREE.WebGLRenderer({ antialias: false });
      }

      // Set some properties
      //renderer.setSize(800, 500);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x72645b, 1);
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;

      // Check if we have a mobile, and decrease pixel ratio to improve perfomance
      if(mobilecheck()){
        renderer.setPixelRatio( 0.6 );
      } else {
        renderer.setPixelRatio( window.devicePixelRatio );
      }

      // Hack to avoid warning display
      renderer.context.getShaderInfoLog = function () { return '' };

      // Add an id for the renderer dom element
      renderer.domElement.id = "canvasRenderer";

      // Append the dom element to page
      document.body.appendChild(renderer.domElement);

      // If we have recreated dom update orbit controls
      if(recreateDom){
        // Disable last controls
        controls.reset();
        controls.enabled = false;

        // Add a mouse controller for this scene
        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Disable vertical rotation below ground plane
        controls.maxPolarAngle = Math.PI/2 - 0.1;
        controls.minPolarAngle = -Math.PI/2;
      }
    }

    // Create a dat.gui interface to control bones
    function createGui(){
      // Create an empty interface
      var gui = new dat.GUI()//{autoPlace: false});

      // Append gui to renderer dom element
      //renderer.domElement.appendChild(gui.domElement);

      // Bones rotation backup
      var bonesRotationBackup = [];
      for(var i = 1; i < bonesArray.length; i++){
        if(i % 2 === 1){
          bonesRotationBackup[i] = bonesArray[i].rotation.y;
        } else {
          bonesRotationBackup[i] = bonesArray[i].rotation.z;
        }
      }

      // Rotation of each object
      var BonesRotations = {
        bone0Rotation: bonesArray[0].rotation.y,
        bone0Position: bonesArray[0].position.y,

        bone1Rotation: bonesArray[1].rotation.y,
        bone2Rotation: bonesArray[2].rotation.z,

        bone3Rotation: bonesArray[3].rotation.y,
        bone4Rotation: bonesArray[4].rotation.z,

        bone5Rotation: bonesArray[5].rotation.y,
        bone6Rotation: bonesArray[6].rotation.z,

        bone7Rotation: bonesArray[7].rotation.y,
        bone8Rotation: bonesArray[8].rotation.z
      };

      // Renderer settings
      var RendererSettings = {
        pixelRatio: renderer.getPixelRatio(),
        enableAntiAlias: false,
        lastEnable: false,
        setConfig: function(){
          // Change renderer pixel ratio
          renderer.setPixelRatio(this.pixelRatio);

          // Check if lastEnable is being maintaned otherwise recreate renderer
          if(this.enableAntiAlias !== this.lastEnable){
            this.lastEnable = this.enableAntiAlias;

            // Enable or disable antialias
            createRenderer(this.enableAntiAlias);
          }
        },
        resetCamera: function(){
          // Reset orbit controls
          controls.reset();
        },
        resetControls: function(){
          // Reset body position
          bonesArray[0].position.y = 0;
          bonesArray[0].rotation.y = 0;
          BonesRotations["bone0Rotation"] = 0;
          BonesRotations["bone0Position"] = 0;

          // Reset bones rotation to 0
          for(var i = 1; i < bonesArray.length; i++){
            if(i % 2 === 1){
              bonesArray[i].rotation.y = bonesRotationBackup[i];
              BonesRotations["bone" + i + "Rotation"] = bonesRotationBackup[i];
            } else {
              bonesArray[i].rotation.z = bonesRotationBackup[i];
              BonesRotations["bone" + i + "Rotation"] = bonesRotationBackup[i];
            }
          }
        }
      };

      // Add different configurations of pixel ratio
      gui.add(RendererSettings, "pixelRatio", {
        "EXTREMELY ULTRA FAST": 0.1,
        "ULTRA FAST": 0.25,
        "FAST": 0.4,
        "NORMAL": 0.6,
        "REGULAR": 0.8,
        "GOOD": 1,
        "AWESOME": 2
      });

      // Add option to enable or disable anti alias
      gui.add(RendererSettings, "enableAntiAlias");

      // Change pixel ratio
      gui.add(RendererSettings, "setConfig");

      // Add option to reset camera position
      gui.add(RendererSettings, "resetCamera");

      // Add option to back bones to zero
      gui.add(RendererSettings, "resetControls");

      // Function to display graus to radians
      function onChangeDegToRad(index, axis, increase){
        return ((value) => {
          bonesArray[index].rotation[axis] = THREE.Math.degToRad(value + increase);
        });
      }

      // Body folder
      var bodyFolder = gui.addFolder("Body");
      bodyFolder.add(BonesRotations, "bone0Rotation", -90, 90)
                .step(1)
                .onChange(onChangeDegToRad(0, "y", 0))
                .listen()
                .name("Body Rotation")
      bodyFolder.add(BonesRotations, "bone0Position", -35, 200)
                .step(1)
                .onChange(function(value){
                  bonesArray[0].position.y = value;
                })
                .listen()
                .name("Body Height")

      // Folder names
      var folderNames = [
        "FrontLeft",
        "BackLeft",
        "FrontRight",
        "BackRight"
      ];

      // Create controllers from 0 to 180 of rotion of each bone
      for(var i = 1, j = 1; i < bonesArray.length; i += 2, j++){
        // Create a folder for each bone
        var boneFolder = gui.addFolder("Arm / Leg - " + folderNames[j - 1]);

        // Add controler for rotation of arm
        if(j <= 2){
          boneFolder.add(BonesRotations, "bone" + i + "Rotation", -90, 90)
                    .step(1)
                    .onChange(onChangeDegToRad(i, "y", 0))
                    .listen()
                    .name("Arm Rotation")
        } else {
          boneFolder.add(BonesRotations, "bone" + i + "Rotation", -90, 90)
                    .step(1)
                    .onChange(onChangeDegToRad(i, "y", 180))
                    .listen()
                    .name("Arm Rotation")
        }

        // Add controler for rotation of this leg
        boneFolder.add(BonesRotations, "bone" + (i + 1) + "Rotation", -90, 45)
                  .step(1)
                  .onChange(onChangeDegToRad((i + 1), "z", 0))
                  .listen()
                  .name("Leg Rotation")
      }
    }

    // Return true if it's mobile and false otherwise
    // <3 https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
    function mobilecheck (){
      if( navigator.userAgent.match(/Android/i)
         || navigator.userAgent.match(/webOS/i)
         || navigator.userAgent.match(/iPhone/i)
         || navigator.userAgent.match(/iPad/i)
         || navigator.userAgent.match(/iPod/i)
         || navigator.userAgent.match(/BlackBerry/i)
         || navigator.userAgent.match(/Windows Phone/i) ){
        return true;
      }

      return false;
    };

    // Update camera and renderer if the window resize
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    /*
    function CameraControl(renderer, camera, updateCallback) {
      var _this = this;
      this.camera = camera;
      this.zoomMode = false;
      this.press = false;
      this.sensitivity = 0.4;

      renderer.domElement.addEventListener('mousemove', function (event) {
        if (!_this.press) {
          return;
        }

        if (event.button == 0) {
          camera.position.y -= event.movementY * _this.sensitivity;
          camera.position.x -= event.movementX * _this.sensitivity;
        }
        else if (event.button == 2) {
          camera.quaternion.y -= event.movementX * _this.sensitivity / 10;
          camera.quaternion.x -= event.movementY * _this.sensitivity / 10;
        }

        //camera.lookAt(scene.position);
        updateCallback();
      });

      renderer.domElement.addEventListener('mousedown', function () { _this.press = true; });
      renderer.domElement.addEventListener('mouseup', function () { _this.press = false; });
      renderer.domElement.addEventListener('mouseleave', function () { _this.press = false; });
      document.addEventListener('keydown', function (event) {
        if (event.key == 'Shift') {
          _this.zoomMode = true;
        }
      });

      document.addEventListener('keyup', function (event) {
        if (event.key == 'Shift') {
          _this.zoomMode = false;
        }
      });

      renderer.domElement.addEventListener('mousewheel', function (event) {
        if (_this.zoomMode) {
          camera.fov += event.wheelDelta * _this.sensitivity;
          camera.updateProjectionMatrix();
        }
        else {
          camera.position.z += event.wheelDelta * _this.sensitivity;
        }
        updateCallback();
      });
    }
    */

    /*
    function render(){
      //var timer=Date.now() * 0.0005;
      r=150;
      camera.position.x= 0; // r * Math.cos(timer);
      camera.position.z= r; // r * Math.sin(timer);
      camera.lookAt(scene.position);
      renderer.render(scene, camera);
      renderer.setClearColor(0xf5f5f5, 1);
    }
    */

    /*
    // Create a scene that will hold all our elements
    var scene = new THREE.Scene();

    // Create a camera which define where we are looking at.
    var camera = new THREE.PerspectiveCamera( 35, 800/500, 1, 10000 );
    camera.position.set(3, 0.5, 3);
    camera.lookAt(scene.position);

    // Create a render and set the size
    var renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0xf5f5f5, 1);
    renderer.setSize(800, 500);

    // Create ambient light
    var ambientLight = new THREE.AmbientLight(0x736F6E);
    scene.add(ambientLight);

    // Create directional light
    var directionalLight=new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position = camera.position;
    scene.add(directionalLight);

    // Add the output of the renderer to the html body
    document.body.appendChild( renderer.domElement );

    // Create a STL Loader to loader STL files
    var loader = new THREE.STLLoader();

    // Add a listener to color every stl file loaded
    loader.addEventListener('load', function (event){
      var geometry=event.content;
      var material=new THREE.MeshLambertMaterial({ ambient: 0xFBB917,color: 0xfdd017 });
      var mesh=new THREE.Mesh(geometry, material);
      scene.add(mesh);
    });

    // Load the STL file
    loader.load("../leg1_mold_for_SG90.stl");

    renderer.render(scene, camera);
    */

	</script>

</body>

</html>
