<!DOCTYPE html>
<html>

<head>
  <meta charset=utf-8>
	<title>My first three.js app</title>
	<style>
		html, body {
      margin: 0 auto;
      padding: 0;
      width: 100%;
      height: 100%;
    }
    body{
      display: flex;
      align-items: center;
    }
		canvas {
      margin: 0 auto;
      width: 800px !important;
      height: 500px !important;
    }
	</style>
</head>

<body>

  <script src="js/three.js"></script>
  <script src="js/STLLoader.js"></script>
  <script src="js/TrackballControls.js"></script>

	<script>

    // Global objects
    var camera,
        scene,
        renderer,
        controls,
        axes,
        groundPlane,
        meshObjects,
        bonesArray,
        bonesArticulations,
        quadrupedSkeleton;

    // Box Helpers
    var boxHelperVector = [];

    // Groups are collection of meshs
    var meshGroups = {
      servoModel: {
        isBone: false,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {}
      },
      legSupport: {
        isBone: true,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          legServo: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: 0,
                y: 0,
                z: 0
              },
              rotation: {
                x: 0,
                y: 0,
                z: 0
              }
            }
          }
        }
      },
      servoSupport:{
        isBone: true,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          legServo: {
            groupModel: "legSupport",
            properties: {
              position: {
                x: 0,
                y: 0,
                z: 0
              },
              rotation: {
                x: 0,
                y: 0,
                z: 0
              }
            }
          }
        }
      },
      legModel:{
        isBone: true,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          legServo: {
            groupModel: "servoSupport",
            properties: {
              position: {
                x: 0,
                y: -40.5,
                z: -1.6
              },
              rotation: {
                x: 0,
                y: 0,
                z: 0
              }
            }
          }
        }
      },
      bodyCover: {
        isBone: false,
        visible: false,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          staticServoFL: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: -31,
                y: 5,
                z: 26.9
              },
              rotation: {
                x: THREE.Math.degToRad(90),
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(270)
              }
            }
          },
          staticServoFR: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: 31,
                y: 5,
                z: 26.9
              },
              rotation: {
                x: THREE.Math.degToRad(90),
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(270)
              }
            }
          },
          staticServoBL: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: -31,
                y: 5,
                z: -26.9
              },
              rotation: {
                x: THREE.Math.degToRad(90),
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(90)
              }
            }
          },
          staticServoBR: {
            groupModel: "servoModel",
            properties: {
              position: {
                x: 31,
                y: 5,
                z: -26.9
              },
              rotation: {
                x: THREE.Math.degToRad(90),
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(90)
              }
            }
          }
        }
      },
      body:{
        isBone: true,
        visible: true,
        groupObject: null,
        meshChilds: {},
        usedObjects: {
          staticBody: {
            groupModel: "bodyCover",
            properties: {
              position: {
                x: 0,
                y: 47.5,
                z: 0
              },
              rotation: {
                x: 0,
                y: 0,
                z: 0
              }
            }
          },
          legFrontLeft:{
            groupModel: "legModel",
            properties: {
              position: {
                x: -31,
                y: 53.5,
                z: 26.8
              },
              rotation: {
                x: 0,
                y: 0,
                z: THREE.Math.degToRad(270)
              }
            }
          },
          legBackLeft:{
            groupModel: "legModel",
            properties: {
              position: {
                x: -31,
                y: 53.5,
                z: -26.8
              },
              rotation: {
                x: 0,
                y: 0,
                z: THREE.Math.degToRad(270)
              }
            }
          },
          legBackRight:{
            groupModel: "legModel",
            properties: {
              position: {
                x: 31,
                y: 53.5,
                z: -26.8
              },
              rotation: {
                x: 0,
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(270)
              }
            }
          },
          legFrontRight:{
            groupModel: "legModel",
            properties: {
              position: {
                x: 31,
                y: 53.5,
                z: 26.8
              },
              rotation: {
                x: 0,
                y: THREE.Math.degToRad(180),
                z: THREE.Math.degToRad(270)
              }
            }
          }
        }
      }
    }

    // ----------------------------------------------------------

    // Objects positions
    var objsToLoad = {
      sg90Servo : {
        path: "./parts/sg90Servo.stl",
        groups: ["servoModel"],
        properties: {
          position: {
            x: -9.85,
            y: -51,
            z: 5
          },
          rotation: {
            x: 0,
            y: 0,
            z: 0
          }
        }
      },
      servoBottom : {
        path: "./parts/servoBottom.stl",
        groups: ["servoModel"],
        properties: {
          position: {
            x: 5.3,
            y: 0,
            z: -11
          },
          rotation: {
            x: 0,
            y: THREE.Math.degToRad(180),
            z: THREE.Math.degToRad(-90)
          }
        }
      },
      servoSupportX : {
        path: "./parts/servoSupport.stl",
        groups: ["servoSupport"],
        properties: {
          position: {
            x: 5.4,
            y: 11,
            z: 15
          },
          rotation: {
            x: THREE.Math.degToRad(-90),
            y: THREE.Math.degToRad(-90),
            z: THREE.Math.degToRad(180)
          },
          scale: {
            x: 1,
            y: 0.9,
            z: 0.9
          }
        }
      },
      servoSupportY : {
        path: "./parts/servoSupport.stl",
        groups: ["servoSupport"],
        properties: {
          position: {
            x: -13.2,
            y: 29.4,
            z: -3.7
          },
          rotation: {
            x: THREE.Math.degToRad(180),
            y: THREE.Math.degToRad(180),
            z: THREE.Math.degToRad(-90)
          },
          scale: {
            x: 1,
            y: 0.9,
            z: 0.9
          }
        }
      },
      leg : {
        path: "./parts/leg.stl",
        groups: ["legSupport"],
        properties: {
          position: {
            x: 5,
            y: 0,
            z: -5
          },
          rotation: {
            x: 0,
            y: 0,
            z: THREE.Math.degToRad(90)
          }
        }
      },
      bodyCover : {
        path: "./parts/bodyCover.stl",
        groups: ["bodyCover"],
        properties: {
          position: {
            x: 0,
            y: 10,
            z: 0
          },
          rotation: {
            x: THREE.Math.degToRad(-90),
            y: 0,
            z: THREE.Math.degToRad(180)
          }
        }
      },
      body : {
        path: "./parts/body.stl",
        groups: ["bodyCover"],
        properties: {
          position: {
            x: 0,
            y: 10,
            z: 0
          },
          rotation: {
            x: THREE.Math.degToRad(90),
            y: 0,
            z: 0
          }
        }
      },
      bodyBottom : {
        path: "./parts/bodyBottom.stl",
        groups: ["bodyCover"],
        properties: {
          position: {
            x: 0,
            y: 0,
            z: 0
          },
          rotation: {
            x: THREE.Math.degToRad(90),
            y: 0,
            z: THREE.Math.degToRad(180)
          }
        }
      }
    };

    // Size of objsToLoad
    // <3 https://stackoverflow.com/questions/126100/how-to-efficiently-count-the-number-of-keys-properties-of-an-object-in-javascrip
    var objsToLoadSize = Object.keys(objsToLoad).length;

    // Box3 Temp reusable object
    // <3 https://stackoverflow.com/questions/41459512/from-boundingboxhelper-to-boxhelper
    var box3Size = new THREE.Box3();
    var objSize = new THREE.Vector3();

    // Count number of objects loaded
    var LOADED_OBJECTS_NUMBER = 0;

    // Init content and animate it's scene
    init();
    animate();

    // Init function
    function init(){

      // Create a new scene
      scene = new THREE.Scene();

      // TODO Add a different background color
      //scene.background = new THREE.Color( 0x72645b );

      // TODO Add a fog enviroment at end
      //scene.fog = new THREE.Fog( 0x72645b, 300, 450 );

      // Create a new WebGLRenderer, set it's size and it's color
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(800, 500);
      renderer.setClearColor(0xf5f5f5, 1);
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;

      // Antialias the shadows
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Hack to avoid warning display
      renderer.context.getShaderInfoLog = function () { return '' };

      // Create a new camera
      camera = new THREE.PerspectiveCamera(50, 800 / 500, 1, 10000);
      camera.position.set(0, 150, 250);
      camera.lookAt(scene.position);

      // Create a fake camera and render a custom frame just to update projection matrix
      // of this camera and project the camera helper accordily
      var fakeCamera = new THREE.PerspectiveCamera(50, 800 / 500, 1, 10000);
      fakeCamera.position.set(0, 150, 250);
      fakeCamera.lookAt(scene.position);
      renderer.render(scene, fakeCamera);

      // Add a camera helper to help with orientation
      var cameraHelper = new THREE.CameraHelper( fakeCamera );
      cameraHelper.matrixAutoUpdate = false;
      scene.add( cameraHelper );

      // Add a grid to help with orientation
      var gridHelper = new THREE.GridHelper( 400, 40, 0x0000ff, 0x808080 );
  		scene.add(gridHelper);

      // Create an axis helper to help with orientation
      axes = new THREE.AxesHelper(1000);
      axes.position.y = 0.1;
      scene.add(axes);

      // Create an hemisphere light and add it to scene
      var hemisphereLight = new THREE.HemisphereLight(0x443333, 0x111122);
      scene.add(hemisphereLight);

      // Create an spotlight, which can cast shadows
      var spotLight = new THREE.SpotLight( 0xffffff );
      spotLight.position.set( 0, 200, 200 );

      // Enable shadow
      spotLight.castShadow = true;

      // Configure map size
      spotLight.shadow.mapSize.width = 1024;
      spotLight.shadow.mapSize.height = 1024;

      // Configure shadow
      spotLight.shadow.camera.near = 2;
      spotLight.shadow.camera.far = 800;
      spotLight.shadow.camera.fov = 1;

      // Add spotlight to scene
      scene.add(spotLight);

      // Add a spotlight helper to help orientation
      var spotLightHelper = new THREE.SpotLightHelper( spotLight );
      scene.add( spotLightHelper );

      // Create the loader for STL files
      var loader = new THREE.STLLoader();

      // Add a plane to represent ground on this scene
      var planeGeometry = new THREE.PlaneBufferGeometry(400, 400, 32, 32);
      var planeMaterial = new THREE.MeshStandardMaterial({ color: 0xfffffff });
      groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
      groundPlane.rotation.x = THREE.Math.degToRad(-90);
      groundPlane.receiveShadow = true;
      scene.add(groundPlane);

      // Create an array to organize every mesh
      meshObjects = [];

      // Add a event listener to all objects
      function loadSTL(objName){

        return ((geometry) => {

          // Create material which is the apparence of the object
          var material = new THREE.MeshPhongMaterial({
            color: 0xCCC,
            specular: 0x111111,
            shininess: 200
          });

          // Join geometry and it's material to create the mesh
          var mesh = new THREE.Mesh(geometry, material);

          // Add shadow to the mesh
          mesh.castShadow = true;
          mesh.receiveShadow = true;

          // If this object has custom properties change them now
          for(let propertyName in objsToLoad[objName].properties){
            for(let propertyValue in objsToLoad[objName].properties[propertyName]){
              mesh[propertyName][propertyValue] = objsToLoad[objName].properties[propertyName][propertyValue];
            }
          }

          // Add copies of this mesh to the custom groups
          for(var i = 0; i < objsToLoad[objName].groups.length; i++){
            // Group name
            var groupName = objsToLoad[objName].groups[i];
            console.log("Cloning mesh " + objName + " to group " + groupName);

            // Create a clone of this mesh
            var meshClone = mesh.clone();

            // Add this copie to the group and the array of meshs in group
            meshGroups[groupName].groupObject.add(meshClone);
            meshGroups[groupName].meshChilds[objName] = meshClone;
          }

          // Add the object to scene if this mesh don't belong to a group
          if(objsToLoad[objName].groups.length === 0){
            console.log("Obj " + objName + " being added to scene");
            meshObjects[objName] = mesh;
            scene.add(mesh);

            // In DEBUG situations add a box helper to mesh to check it's sizes
            var boxHelper = new THREE.BoxHelper( mesh, 0xffff00 );
            scene.add(boxHelper);
            boxHelperVector.push(boxHelper);

            // Display object size
            displayObjectSize(objName, boxHelper);
          }

          // Increment counter of loaded objects
          LOADED_OBJECTS_NUMBER++;

          // If all objects are loaded then call function to organize groups
          if(LOADED_OBJECTS_NUMBER === objsToLoadSize){
            organizeGroups();
          }

        });

      }

      // Initialize mesh groups
      for(let groupName in meshGroups){

        // Create the group object or bone object
        if(meshGroups[groupName].isBone){
          meshGroups[groupName].groupObject = new THREE.Bone();
        } else {
          meshGroups[groupName].groupObject = new THREE.Group();
        }

        // Create a box to represent pivot
        // TODO Not necessarily now, maybe on the future

      }

      // Load all stl files in the desired position
      for(let stlObj in objsToLoad){
        console.log("Loading - " + objsToLoad[stlObj].path);
        loader.load(objsToLoad[stlObj].path, loadSTL(stlObj));
      }

      // Append the dom element to page
      document.body.appendChild(renderer.domElement);

      // Add a mouse controller for this scene
      controls = new THREE.TrackballControls(camera, renderer.domElement);

      // Add an event listener to reset camera position
      document.addEventListener('keypress', (event) => {
        // Get pressed key
        var key = event.which || event.keyCode;

        // Uncomment this to discover what is the code ok key pressed
        //console.log("DEBUG -- Key pressed => " + key);

        // Key 'r' has code 114
        var keyR = 114;

        // Check if pressed key b and reset it's control
        if(key === keyR){
          controls.reset();
          console.log("Resetting controls...");
        }
      });
    }

    // Animate scene
    function animate(){

      // Request this animation frame recursively
      requestAnimationFrame(animate);

      // Update controls
      controls.update();

      // Update box helpers in scene
      for(var i = 0; i < boxHelperVector.length; i++){
        boxHelperVector[i].update();
      }

      // Re-render this scene
      render();
    }

    // Render scene content
    function render(){
      renderer.render(scene, camera);
    }

    // Display size of an 3D Object
    function displayObjectSize(objName, obj){
      // Get a bounding box from the obj
      box3Size.setFromObject(obj);

      // Change size vector3 to display size of this object
      box3Size.getSize(objSize);

      // Display object size
      console.log("Sizes of " + objName +
                  " X: " + objSize.x,
                  " Y: " + objSize.y,
                  " Z: " + objSize.z);
    }

    // Organize groups since all content are loaded
    function organizeGroups(){

      // Debug message
      console.log("Organizing groups...");

      // For each group in mesh groups
      for(let groupName in meshGroups){

        // Check if we use another object inside this group and add a copy of it to this
        for(let auxObjID in meshGroups[groupName].usedObjects){

          // Get auxObjName with obj id
          var auxObjName = meshGroups[groupName].usedObjects[auxObjID].groupModel;

          // Copy of aux obj
          var cloneAuxObj = meshGroups[auxObjName].groupObject.clone();

          // Add this aux obj to the current group
          console.log("Appending obj " + auxObjName + " to group " + groupName);
          meshGroups[groupName].groupObject.add(cloneAuxObj);
          meshGroups[groupName].meshChilds[auxObjID] = cloneAuxObj;

          // In case of this cloned group has custom properties change them now
          for(let propertyName in meshGroups[groupName].usedObjects[auxObjID].properties){
            for(let propertyValue in meshGroups[groupName].usedObjects[auxObjID].properties[propertyName]){
              cloneAuxObj[propertyName][propertyValue] = meshGroups[groupName].usedObjects[auxObjID]
                                                                              .properties[propertyName][propertyValue];
            }
          }
        }

        // Add this group to scene if it's visible
        if(meshGroups[groupName].visible){
          // In DEBUG situations add a box helper to mesh to check it's sizes
          var boxHelper = new THREE.BoxHelper( meshGroups[groupName].groupObject, 0xffff00 );
          scene.add(boxHelper);
          boxHelperVector.push(boxHelper);

          window.HAHA = meshGroups[groupName];

          // Bones array, add this as first bone
          bonesArray = [meshGroups[groupName].groupObject];

          // Bones articulations 
          // TODO since now we have only one bone per articulation create an obj
          // with a list of bones per articulation
          bonesArticulations = {};

          // For every bone which belong to childs of this group
          for(let groupNameID in meshGroups[groupName].meshChilds){
            
            // Check if it's a bone
            if(meshGroups[groupName].meshChilds[groupNameID].type === "Bone"){
              // Get reference of the actual boneObj
              var boneObj = meshGroups[groupName].meshChilds[groupNameID]; 
              
              // Add a green box helper for articulations
              var boxHelper = new THREE.BoxHelper( boneObj, 0x002aff );
              scene.add(boxHelper);
              boxHelperVector.push(boxHelper);

              // Since we are a bone add this to list of bones
              bonesArray.push(boneObj);

              // Save an array of bones in this articulation to change properties after
              bonesArticulations[groupNameID] = [];

              // This function return every bone in an articulation
              function returnBonesRec(objsBones, bonesFound){

                // Check children of this bone
                for(var i = 0; i < objsBones.children.length; i++){
                  // Check if it's a bone and call this function recursively
                  if(objsBones.children[i].type === "Bone"){
                    // Get actual bone
                    var actualBone = objsBones.children[i];

                    // Add a blue box helper to basic bones
                    var boxHelper = new THREE.BoxHelper( actualBone, 0x00ff19 );
                    scene.add(boxHelper);
                    boxHelperVector.push(boxHelper);

                    // Add to the array of bones
                    bonesArray.push(actualBone);

                    // Add to the bonesFound array too
                    bonesFound.push(actualBone);

                    // Call this function recursively
                    returnBonesRec(actualBone, bonesFound);
                  }
                }
              }
 
              // Get all bones of this articulation
              returnBonesRec(boneObj, bonesArticulations[groupNameID]);
            }

            // Quadruped skeleton
            quadrupedSkeleton = new THREE.Skeleton( bonesArray );

            // Bind skeleton to this group mesh
            //meshGroups[groupName].groupObject.bind(quadrupedSkeleton);

            // Add a skeleton helper to scene
            //var skeletonHelper = new THREE.SkeletonHelper( quadrupedSkeleton );
            //skeletonHelper.material.linewidth = 3;
            //scene.add( skeletonHelper );

          }

          // Add group to scene
          scene.add(meshGroups[groupName].groupObject);
        }

      }

    }

    /*
    function CameraControl(renderer, camera, updateCallback) {
      var _this = this;
      this.camera = camera;
      this.zoomMode = false;
      this.press = false;
      this.sensitivity = 0.4;

      renderer.domElement.addEventListener('mousemove', function (event) {
        if (!_this.press) {
          return;
        }

        if (event.button == 0) {
          camera.position.y -= event.movementY * _this.sensitivity;
          camera.position.x -= event.movementX * _this.sensitivity;
        }
        else if (event.button == 2) {
          camera.quaternion.y -= event.movementX * _this.sensitivity / 10;
          camera.quaternion.x -= event.movementY * _this.sensitivity / 10;
        }

        //camera.lookAt(scene.position);
        updateCallback();
      });

      renderer.domElement.addEventListener('mousedown', function () { _this.press = true; });
      renderer.domElement.addEventListener('mouseup', function () { _this.press = false; });
      renderer.domElement.addEventListener('mouseleave', function () { _this.press = false; });
      document.addEventListener('keydown', function (event) {
        if (event.key == 'Shift') {
          _this.zoomMode = true;
        }
      });

      document.addEventListener('keyup', function (event) {
        if (event.key == 'Shift') {
          _this.zoomMode = false;
        }
      });

      renderer.domElement.addEventListener('mousewheel', function (event) {
        if (_this.zoomMode) {
          camera.fov += event.wheelDelta * _this.sensitivity;
          camera.updateProjectionMatrix();
        }
        else {
          camera.position.z += event.wheelDelta * _this.sensitivity;
        }
        updateCallback();
      });
    }
    */

    /*
    function render(){
      //var timer=Date.now() * 0.0005;
      r=150;
      camera.position.x= 0; // r * Math.cos(timer);
      camera.position.z= r; // r * Math.sin(timer);
      camera.lookAt(scene.position);
      renderer.render(scene, camera);
      renderer.setClearColor(0xf5f5f5, 1);
    }
    */

    /*
    // Create a scene that will hold all our elements
    var scene = new THREE.Scene();

    // Create a camera which define where we are looking at.
    var camera = new THREE.PerspectiveCamera( 35, 800/500, 1, 10000 );
    camera.position.set(3, 0.5, 3);
    camera.lookAt(scene.position);

    // Create a render and set the size
    var renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0xf5f5f5, 1);
    renderer.setSize(800, 500);

    // Create ambient light
    var ambientLight = new THREE.AmbientLight(0x736F6E);
    scene.add(ambientLight);

    // Create directional light
    var directionalLight=new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position = camera.position;
    scene.add(directionalLight);

    // Add the output of the renderer to the html body
    document.body.appendChild( renderer.domElement );

    // Create a STL Loader to loader STL files
    var loader = new THREE.STLLoader();

    // Add a listener to color every stl file loaded
    loader.addEventListener('load', function (event){
      var geometry=event.content;
      var material=new THREE.MeshLambertMaterial({ ambient: 0xFBB917,color: 0xfdd017 });
      var mesh=new THREE.Mesh(geometry, material);
      scene.add(mesh);
    });

    // Load the STL file
    loader.load("../leg1_mold_for_SG90.stl");

    renderer.render(scene, camera);
    */

	</script>

</body>

</html>
